<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Digital Marketing</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    body {
      font-family: system-ui, sans-serif;
      background: #020617;
      color: #e5e7eb;
      min-height: 100vh;
      padding: 2rem 1rem 3rem;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1.25rem;
    }

    h1 {
      margin: 0;
    }

.controls {
  display: flex;
  gap: 0.75rem;
  flex-wrap: wrap;
  justify-content: center;
      width: 100%;
      max-width: 680px;
    }

button {
  padding: 0.55rem 1.2rem;
  border-radius: 999px;
  border: none;
  background: #38bdf8;
      color: #020617;
      font-weight: 700;
      cursor: pointer;
      transition: transform 0.1s ease, box-shadow 0.2s ease;
    }

button:hover {
  transform: translateY(-1px);
  box-shadow: 0 10px 25px rgba(56, 189, 248, 0.35);
}

button:disabled {
  opacity: 0.55;
  cursor: not-allowed;
  box-shadow: none;
  transform: none;
}

button.active {
  background: #22c55e;
  color: #022c22;
}

.deck {
  width: 100%;
  max-width: 780px;
  position: relative;
  display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.75rem;
    }

    .progress {
      font-size: 0.95rem;
      letter-spacing: 0.02em;
      color: #cbd5e1;
    }

    .card {
      width: 100%;
      max-width: 780px;
      height: 360px;
      perspective: 1200px;
      cursor: default;
      touch-action: pan-y;
    }

    .card-inner {
      width: 100%;
      height: 100%;
      position: relative;
      transform-style: preserve-3d;
      transition: transform 0.4s ease;
      border-radius: 18px;
      box-shadow: 0 25px 60px rgba(0, 0, 0, 0.35);
    }

    .card.flipped .card-inner {
      transform: rotateY(180deg);
    }

    .face {
      position: absolute;
      inset: 0;
      background: linear-gradient(135deg, #0f172a, #111827);
      border-radius: 18px;
      padding: 1.25rem;
      backface-visibility: hidden;
      display: flex;
      flex-direction: column;
      gap: 0.6rem;
    }

    .back {
      transform: rotateY(180deg);
      background: linear-gradient(135deg, #0b3b5c, #0a4b78);
      color: #e5f2ff;
    }

    .meta {
      font-size: 0.9rem;
      color: #93c5fd;
      letter-spacing: 0.02em;
    }

    h2 {
      font-size: 1.05rem;
      margin: 0;
      line-height: 1.4;
    }

    ul {
      padding-left: 1.1rem;
      margin: 0;
      display: grid;
      gap: 0.25rem;
      font-size: 0.95rem;
    }

    .options {
      display: grid;
      gap: 0.4rem;
    }

    .option {
      text-align: left;
      border: 1px solid #1f2937;
      background: #0b1220;
      color: #e5e7eb;
      padding: 0.55rem 0.7rem;
      border-radius: 12px;
      cursor: pointer;
      transition: border-color 0.2s ease, background 0.2s ease;
    }

    .option:hover {
      border-color: #38bdf8;
      background: #0f172a;
    }

    .option.correct {
      border-color: #22c55e;
      background: #0f2a1d;
      color: #d1fae5;
    }

    .option.incorrect {
      border-color: #ef4444;
      background: #2a0f12;
      color: #fecdd3;
    }

    .answer {
      font-weight: 700;
    }

    .feedback {
      margin-top: 0.5rem;
      padding: 0.75rem;
      border-radius: 12px;
      background: #0b1324;
      border: 1px solid #1f2937;
      font-size: 0.9rem;
      display: grid;
      gap: 0.25rem;
      color: #cbd5e1;
    }

    .feedback strong {
      color: #e5e7eb;
    }

    .nav-hint {
      font-size: 0.85rem;
      color: #94a3b8;
    }

.stats {
  font-size: 0.95rem;
  color: #cbd5e1;
}

.stats small {
  color: #94a3b8;
}
  </style>
</head>
<body>

<h1>DigitalMarketing</h1>

<div class="controls">
  <button id="prevBtn">← Prev</button>
  <button id="shuffleBtn">Shuffle</button>
  <button id="failedBtn">Practice Failed (0)</button>
  <button id="removeFailedBtn">Remove from Failed</button>
  <button id="resetBtn">Reset</button>
  <button id="nextBtn">Next →</button>
</div>

<div class="deck">
  <div class="progress" id="progress"></div>
  <div class="stats" id="stats"></div>
  <div class="card" id="card">
    <div class="card-inner" id="cardInner">
      <div class="face front" id="front"></div>
      <div class="face back" id="back"></div>
    </div>
  </div>
  <div class="nav-hint">Tap an option to check · Tap elsewhere to advance · Swipe or use buttons to navigate</div>
</div>

<!-- ✅ LOAD DATA FILE -->
<script src="cards.js"></script>

<!-- ✅ MAIN APP LOGIC -->
<script>
  const progressEl = document.getElementById("progress");
  const statsEl = document.getElementById("stats");
  const cardEl = document.getElementById("card");
  const cardInner = document.getElementById("cardInner");
  const front = document.getElementById("front");
  const back = document.getElementById("back");
  const failedBtn = document.getElementById("failedBtn");
  const removeFailedBtn = document.getElementById("removeFailedBtn");
  const FAILED_STORAGE_KEY = "flashcards_failed_indexes";
  const SEQUENCE_STORAGE_KEY = "flashcards_sequence_state";

  let order = [...cards];
  let index = 0;
  let didSwipe = false;
  let feedbackEl = null;
  let selectionState = new Map(); // question -> boolean (correct?)
  let performance = new Map(); // question -> {attempts, correct, wrong}
  let failedIndexes = loadFailedIndexes();
  let showingFailedOnly = false;

  const shuffle = (arr) => [...arr].sort(() => Math.random() - 0.5);

  const getPerf = (question) =>
    performance.get(question) || { attempts: 0, correct: 0, wrong: 0 };

  const getFailedCards = () =>
    [...failedIndexes]
      .map((idx) => {
        const card = cards[idx];
        return card ? { card, idx, stats: getPerf(card.question) } : null;
      })
      .filter(Boolean)
      .sort(
        (a, b) =>
          b.stats.wrong - a.stats.wrong ||
          b.stats.attempts - a.stats.attempts ||
          a.idx - b.idx
      )
      .map((entry) => entry.card);

  function loadFailedIndexes() {
    try {
      const raw = localStorage.getItem(FAILED_STORAGE_KEY);
      const parsed = raw ? JSON.parse(raw) : [];
      if (Array.isArray(parsed)) {
        return new Set(
          parsed.filter(
            (idx) => Number.isInteger(idx) && idx >= 0 && idx < cards.length
          )
        );
      }
    } catch (err) {
      console.warn("Unable to load failed flashcards", err);
    }
    return new Set();
  }

  function persistFailedIndexes() {
    localStorage.setItem(FAILED_STORAGE_KEY, JSON.stringify([...failedIndexes]));
  }

  function applyFailedIndexesToPerformance() {
    failedIndexes.forEach((idx) => {
      const card = cards[idx];
      if (!card) return;
      if (!performance.has(card.question)) {
        performance.set(card.question, { attempts: 1, correct: 0, wrong: 1 });
      }
    });
  }

  function loadSequenceState() {
    try {
      const raw = localStorage.getItem(SEQUENCE_STORAGE_KEY);
      if (!raw) return null;
      const parsed = JSON.parse(raw);
      const orderIndexes = Array.isArray(parsed?.order) ? parsed.order : [];
      const validOrder = orderIndexes
        .filter(
          (idx) => Number.isInteger(idx) && idx >= 0 && idx < cards.length
        )
        .map((idx) => cards[idx]);
      if (!validOrder.length) return null;

      const savedIndex = Number.isInteger(parsed.index) ? parsed.index : 0;
      const clampedIndex = Math.min(
        validOrder.length - 1,
        Math.max(0, savedIndex)
      );
      return {
        order: validOrder,
        index: clampedIndex,
        showingFailedOnly: !!parsed.showingFailedOnly,
      };
    } catch (err) {
      console.warn("Unable to load sequence state", err);
      return null;
    }
  }

  function persistSequenceState() {
    const orderIndexes = order
      .map((card) => cards.indexOf(card))
      .filter((idx) => idx !== -1);
    localStorage.setItem(
      SEQUENCE_STORAGE_KEY,
      JSON.stringify({
        order: orderIndexes,
        index,
        showingFailedOnly,
      })
    );
  }

  function applySequenceState() {
    const saved = loadSequenceState();
    if (!saved) return;
    order = saved.order;
    index = saved.index;
    showingFailedOnly = saved.showingFailedOnly;
  }

  function syncFailedDeck() {
    if (!showingFailedOnly) return;
    const failed = getFailedCards();
    if (failed.length) {
      order = failed;
      index = Math.min(index, failed.length - 1);
    } else {
      showingFailedOnly = false;
      order = [...cards];
      index = 0;
    }
    renderCard();
  }

  function updateFailedButton() {
    const failedCount = getFailedCards().length;
    failedBtn.textContent = showingFailedOnly
      ? "Practice All"
      : `Practice Failed (${failedCount})`;
    failedBtn.disabled = failedCount === 0 && !showingFailedOnly;
    failedBtn.classList.toggle("active", showingFailedOnly);
  }

  function renderCard() {
    const current = order[index];
    // keep card unflipped; answer/feedback shown inline

    front.innerHTML = `
      <div class="meta">${current.topic || "Topic"}</div>
      <h2>${current.question}</h2>
      <div class="options">
        ${current.options.map((o, i) => `<button class="option" data-idx="${i}">${o}</button>`).join("")}
      </div>
      <div id="feedback" class="feedback" style="display:none;"></div>
    `;

    back.innerHTML = `
      <div class="answer">Answer: ${current.answer}</div>
      <div>${current.explanation || ""}</div>
    `;

    feedbackEl = document.getElementById("feedback");
    progressEl.textContent = `Card ${index + 1} / ${order.length}`;
    updateStats();

    attachOptionHandlers();
    persistSequenceState();
  }

  function updateRemoveFailedButton() {
    const current = order[index];
    if (!current) return;
    const cardIndex = cards.findIndex(
      (card) => card.question === current.question
    );
    const isFailed = cardIndex !== -1 && failedIndexes.has(cardIndex);
    removeFailedBtn.disabled = !isFailed;
  }

  function attachOptionHandlers() {
    const optionButtons = front.querySelectorAll(".option");
    optionButtons.forEach((btn) => {
      btn.addEventListener("click", (e) => {
        e.stopPropagation();
        const selected = btn.textContent.trim();
        const correct = order[index].answer;

        optionButtons.forEach((b) => b.classList.remove("selected", "correct", "incorrect"));
        optionButtons.forEach((b) => {
          if (b.textContent.trim() === correct) {
            b.classList.add("correct");
          }
        });
        if (selected !== correct) {
          btn.classList.add("incorrect");
        }
        optionButtons.forEach((b) => (b.disabled = true));

        showFeedback(selected, correct, order[index].explanation || "");
        const isCorrect = selected === correct;
        const question = order[index].question;
        const stats = getPerf(question);
        performance.set(question, {
          attempts: stats.attempts + 1,
          correct: stats.correct + (isCorrect ? 1 : 0),
          wrong: stats.wrong + (isCorrect ? 0 : 1),
        });
        selectionState.set(order[index].question, selected === correct);
        const failedChanged = syncFailedStorage(question);
        updateStats();
        if (failedChanged) syncFailedDeck();
      });
    });
  }

  function showFeedback(selected, correct, explanation) {
    if (!feedbackEl) return;
    feedbackEl.style.display = "grid";
    feedbackEl.innerHTML = `
      <div><strong>Why:</strong> ${explanation}</div>
    `;
  }

  function updateStats() {
    const answered = selectionState.size;
    const correct = [...selectionState.values()].filter(Boolean).length;
    const failedCards = getFailedCards();
    const topMisses = failedCards.slice(0, 3).map((card) => {
      const stats = getPerf(card.question);
      const label = card.question.length > 60 ? `${card.question.slice(0, 57)}...` : card.question;
      return `${label} (${stats.wrong}/${stats.attempts})`;
    });

    statsEl.innerHTML = `
      Score: ${correct} / ${answered || 0} · Failed cards: ${failedCards.length}
      ${topMisses.length ? `<br><small>Most missed: ${topMisses.join(" · ")}</small>` : ""}
    `;
    updateFailedButton();
    updateRemoveFailedButton();
  }

  function next() {
    index = (index + 1) % order.length;
    renderCard();
  }

  function prev() {
    index = (index - 1 + order.length) % order.length;
    renderCard();
  }

  let touchStartX = 0;
  cardEl.addEventListener("touchstart", (e) => {
    touchStartX = e.touches[0].clientX;
  });
  cardEl.addEventListener("touchend", (e) => {
    const deltaX = e.changedTouches[0].clientX - touchStartX;
    if (Math.abs(deltaX) > 40) {
      didSwipe = true;
      deltaX < 0 ? next() : prev();
    }
  });

  // Click anywhere else on the card (not an option) to advance
  cardEl.addEventListener("click", (e) => {
    if (e.target.closest(".option")) return;
    next();
  });

  document.getElementById("nextBtn").onclick = next;
  document.getElementById("prevBtn").onclick = prev;
  document.getElementById("shuffleBtn").onclick = () => {
    const base = showingFailedOnly ? getFailedCards() : [...cards];
    order = shuffle(base.length ? base : cards);
    index = 0;
    renderCard();
  };
  document.getElementById("resetBtn").onclick = () => {
    order = [...cards];
    index = 0;
    selectionState = new Map();
    showingFailedOnly = false;
    renderCard();
  };
  failedBtn.onclick = () => {
    if (showingFailedOnly) {
      showingFailedOnly = false;
      order = [...cards];
    } else {
      const failed = getFailedCards();
      if (!failed.length) return;
      showingFailedOnly = true;
      order = failed;
    }
    index = 0;
    renderCard();
  };

  function syncFailedStorage(question) {
    const cardIndex = cards.findIndex((card) => card.question === question);
    if (cardIndex === -1) return false;

    const stats = getPerf(question);
    const isFailing = stats.wrong > stats.correct;
    const alreadyFailed = failedIndexes.has(cardIndex);
    if (isFailing && !alreadyFailed) {
      failedIndexes.add(cardIndex);
      persistFailedIndexes();
      return true;
    }
    return false;
  }

  removeFailedBtn.onclick = () => {
    const current = order[index];
    if (!current) return;
    const cardIndex = cards.findIndex(
      (card) => card.question === current.question
    );
    if (cardIndex === -1) return;
    const removed = failedIndexes.delete(cardIndex);
    if (!removed) return;
    persistFailedIndexes();
    updateStats();
    syncFailedDeck();
  };

  applyFailedIndexesToPerformance();
  applySequenceState();
  renderCard();
</script>

</body>
</html>
